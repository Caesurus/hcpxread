package main

import (
	"bytes"
	"encoding/hex"
	"flag"
	"fmt"
	"io/ioutil"
	"math/big"
	"os"
	"strconv"
	"strings"
	"text/tabwriter"

	"github.com/c2h5oh/datasize"
	"github.com/sirupsen/logrus"
)

type Version []byte

func (ver Version) String() (version string) {
	for k, v := range ver {
		version += strconv.Itoa(int(v))
		if k < len(ver)-1 {
			version += "."
		}
	}
	return
}

type MessagePair uint8

func (m MessagePair) Meaning() string {
	if m >= 0 && m <= 5 {
		return "replay counter matching"
	}
	if m >= 128 && m <= 133 {
		return "replay counter was ignored"
	}
	return ""
}

type MAC []byte

func (m MAC) String() (s string) {
	if len(m) == 0 {
		return "00:00:00:00:00:00"
	}
	for k, v := range strings.ToUpper(hex.EncodeToString(m)) {
		s += string(v)
		if k%2 != 0 && k < len(m)*2-1 {
			s += ":"
		}
	}
	return
}

type WPAKey uint8

func (key WPAKey) String() string {
	if key == 1 {
		return "WPA"
	}
	return "WPA2"
}

type HccapxInstance struct {
	Signature   []byte      // the signature (file magic) of .hccapx files, it is always the string HCPX
	Version     Version     // the version number of the .hccapx file format
	MessagePair MessagePair // possible values range from 0 to 5 or 128 to 133

	ESSIDLength uint8  // the length of the network name (ESSID)
	ESSID       string // the network name (ESSID)

	KeyVersion WPAKey // set to 1 if WPA is used, other values (preferably 2) means WPA2
	HashValue  []byte // the actual hash value (MD5 for WPA, SHA1 for WPA2) truncated to 128 bit (16 bytes)

	StationMAC   MAC    // the mac address of the access point (BSSID)
	StationNonce []byte // nonce (random salt) generated by the access point
	ClientMAC    MAC    // the mac address of the client connecting to the access point
	ClientNonce  []byte // nonce (random salt) generated by the client connecting to the access point

	EAPOLLength uint16 // the length of the EAPOL
	EAPOL       []byte // the EAPOL (max 256 bytes)
}

func (h HccapxInstance) Print() {
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.Debug)

	clearScreen(true)
	fmt.Fprintln(w, "Key Version\tESSID\tESSID length\tBSSID\tClient MAC")
	fmt.Fprintf(w, "%s\t%s\t%d\t%s\t%s\n", h.KeyVersion, h.ESSID, h.ESSIDLength, h.StationMAC, h.ClientMAC)
	w.Flush()

	fmt.Println()
	fmt.Fprintln(w, "Handshake messages\tEAPOL Source\tAP message\tSTA message\tReplay counter match")
	mp := MessagePairTable[h.MessagePair]
	fmt.Fprintf(w, "M%d + M%d\tM%d\tM%d\tM%d\t%v\n", mp.APMessage, mp.ClientMessage, mp.EAPOLSource,
		mp.APMessage, mp.ClientMessage, mp.ReplayCounterMatching)
	w.Flush()
}

type HccapxInstances []HccapxInstance

func (h HccapxInstances) Print() {
	w := tabwriter.NewWriter(os.Stdout, 0, 0, 1, ' ', tabwriter.TabIndent)
	fmt.Println()
	for k, v := range h {
		fmt.Fprintf(w, "%d.\t[%s]\t%s\t%s\n", k+1, v.KeyVersion, v.ESSID, v.StationMAC)
	}
	fmt.Fprintln(w, "0.\tExit")
	w.Flush()
}

func (h HccapxInstances) WPANum() (c int) {
	for _, v := range h {
		if v.KeyVersion == 1 {
			c++
		}
	}
	return
}

func (h HccapxInstances) WPA2Num() (c int) {
	for _, v := range h {
		if v.KeyVersion != 1 {
			c++
		}
	}
	return
}

func (h HccapxInstances) UniqueAPs() int {
	aps := make(map[string]bool)
	for _, v := range h {
		aps[v.ESSID] = true
	}
	return len(aps)
}

type MessagePairStructure struct {
	EAPOLSource           uint8
	APMessage             uint8
	ClientMessage         uint8
	ReplayCounterMatching bool
}

var MessagePairTable = map[MessagePair]MessagePairStructure{
	0:   {2, 1, 2, true},
	1:   {4, 1, 4, true},
	2:   {2, 3, 2, true},
	3:   {3, 3, 2, true},
	4:   {3, 3, 4, true},
	5:   {4, 3, 4, true},
	128: {2, 1, 2, false},
	129: {4, 1, 4, false},
	130: {2, 3, 2, false},
	131: {3, 3, 2, false},
	132: {3, 3, 4, false},
	133: {4, 3, 4, false},
}

var (
	capture = flag.String("capture", "", "The HCCAPX `file` to read")
	debug   = flag.Bool("debug", false, "Show additional, debugging info")
)

const BANNER = ` _                                       _
| |__   ___ _ ____  ___ __ ___  __ _  __| |
| '_ \ / __| '_ \ \/ / '__/ _ \/ _` + "` |/ _`" + ` |
| | | | (__| |_) >  <| | |  __/ (_| | (_| |
|_| |_|\___| .__/_/\_\_|  \___|\__,_|\__,_|
           |_|
`

var (
	log        = logrus.New()
	hcpxHeader = []byte{72, 67, 80, 88}
	Instances  HccapxInstances
)

func init() {
	flag.Parse()
	log.SetLevel(logrus.DebugLevel)

	if *capture == "" {
		fmt.Println(BANNER)
		flag.Usage()
		os.Exit(1)
	}
}

func main() {
	clearScreen()
	stat, err := os.Stat(*capture)
	if err != nil {
		log.WithError(err).Fatal("Error stating the file")
	}

	content, err := ioutil.ReadFile(*capture)
	if err != nil {
		log.WithError(err).Fatal("Error reading the file")
	}

	if len(content) < 393 {
		if *debug {
			log.WithField("size", len(content)).Debug("File too small")
		}
		log.WithField("bytes", len(content)).Fatal("File too small for a single HCPX structure")
	}

	fileSize := datasize.ByteSize(stat.Size()).HumanReadable()
	log.WithFields(logrus.Fields{"name": stat.Name(), "size": fileSize}).Info("Opened file for reading")

	fileHeader := content[0:4]
	correctHeader := bytes.Equal(fileHeader, hcpxHeader)

	if !correctHeader {
		log.WithField("header", string(fileHeader)).Fatal("Wrong file header")
	}

	log.Info("Searching for HCPX headers...")
	indexes := SearchHeaders(content)
	log.WithField("indexes", len(indexes)).Info("Finished searching for headers")

	for _, i := range indexes {
		j := i + 393
		h := ParseHccapx(content[i:j])
		Instances = append(Instances, h)
	}

	log.Infof("Summary: %d networks, %d WPA/%d WPA2, %d unique APs",
		len(Instances), Instances.WPANum(), Instances.WPA2Num(), Instances.UniqueAPs())

	var choice int
	for {
		Instances.Print()
		fmt.Printf("\nnetwork > ")

		_, err := fmt.Fscanf(os.Stdin, "%d", &choice)
		if err != nil {
			log.Error(err)
			continue
		}

		if choice <= 0 {
			log.WithField("choice", choice).Info("Exiting, goodbye")
			os.Exit(0)
		}

		if choice > len(Instances) {
			log.Warn("Invalid index")
			continue
		}

		Instances[choice-1].Print()
	}
}

func SearchHeaders(content []byte) (pos []int) {
	for i, j := 0, 0; i < len(content)-4; i++ {
		j = i + 4
		if bytes.Equal(content[i:j], hcpxHeader) {
			if *debug {
				log.WithField("index", i).Debug("Got HCPX header")
			}
			pos = append(pos, i)
		}
	}
	return
}

func ParseHccapx(b []byte) (h HccapxInstance) {
	essid := bytes.Replace(b[10:42], []byte{0}, []byte{}, -1)

	h = HccapxInstance{
		Signature:   b[0:4],
		Version:     b[4:8],
		MessagePair: MessagePair(b[8:9][0]),

		ESSIDLength: uint8(b[9:10][0]),
		ESSID:       string(essid),

		KeyVersion: WPAKey(b[42:43][0]),
		HashValue:  b[43:59],

		StationMAC:   b[59:65],
		StationNonce: b[65:97],
		ClientMAC:    b[97:103],
		ClientNonce:  b[103:135],

		EAPOL: b[137:],
	}

	EAPOLLength := new(big.Int).SetBytes(b[135:137]).Uint64()
	h.EAPOLLength = uint16(EAPOLLength)

	return
}

func clearScreen(nl ...bool) {
	c := "\033[H\033[2J"
	if len(nl) == 1 && nl[0] {
		c += "\n"
	}
	fmt.Print(c)
}
